constant FrogAddr = $2020
constant CarsAddr = $2030
constant InputAddr = $2620
constant ScreenBoundX = $00f0

struct Frog {
  x: $02,
  y: $02,
  tile_index: $01
}

struct Car {
  x: $02,
  y: $02,
  tile_index: $01,
  animation_offset: $01,
  ignore_0: $03,
  vx: $02
}

struct Input {
  up: $01, down: $01,
  left: $01, right: $01,
  a: $01, b: $01,
  start: $01, select: $01
}

start:

check_up_pressed:
  mov8 &[<Input> InputAddr.up], acu
  jeq $00, &[!check_down_pressed]
  mov &[<Frog> FrogAddr.y], r1
  mov $04, r8
  neg r8
  add r8, r1
  mov acu, &[<Frog> FrogAddr.y]

check_down_pressed:
  mov8 &[<Input> InputAddr.down], acu
  jeq $00, &[!check_left_pressed]
  mov &[<Frog> FrogAddr.y], r1
  add $04, r1
  mov acu, &[<Frog> FrogAddr.y]
  
check_left_pressed:
  mov8 &[<Input> InputAddr.left], acu
  jeq $00, &[!check_right_pressed]
  mov &[<Frog> FrogAddr.x], r1
  mov $04, r8
  neg r8
  add r8, r1
  mov acu, &[<Frog> FrogAddr.x]

check_right_pressed:
  mov8 &[<Input> InputAddr.right], acu
  jeq $00, &[!check_input_end]
  mov &[<Frog> FrogAddr.x], r1
  add $04, r1
  mov acu, &[<Frog> FrogAddr.x]

check_input_end:

update_cars:
  mov8 &[!cars_offset], acu ;; load cars offset into the acu
  jeq $30, &[!end_of_update_cars] ;; if the offset is 48, break
  ;; write the next car offset into memory
  mov acu, r5 ;; store current offset into r5
  add $10, acu ;; add 16 to the offset
  movl acu, &[!cars_offset] ;; store the new offset in data8
  mov r5, acu ;; move the current offset back into the acu
  
  add [!CarsAddr], acu ;; calculate address of current car
  
  mov acu, r5 ;; place current car address to r5
  mov &acu, r1  ;; load x position to r1

  add [<Car> &0000.vx], r5 ;; calculate the address of the vx property
  
  mov &acu, acu  ;; place vx into acu
  add acu, r1 ;; add vx to x, place in acu
  mov acu, &r5 ;; move the new x value to the car

  ;; negative bounds detection
  mov acu, r6 ;; move car x to r6
  and acu, $8000 ;; check sign of x
  jne $8000, &[!positive_bounds_check] ;; if x is positive, break
  mov $f0, acu ;; load screen bound into acu
  mov acu, &r5 ;; move the new x value to the car
  jmp [!end_of_bounds_check]

positive_bounds_check:
  mov r6, acu
  jgt $f0, &[!end_of_bounds_check]
  mov $00, acu
  mov acu, &r5

end_of_bounds_check:
  jmp [!update_cars] ;; jump back to the start of the car loop

end_of_update_cars:
  mov $00, &[!cars_offset]

end_of_game_logic:
  mov8 $01, &[!has_ended]
end_of_game_logic_loop:
  jmp [!end_of_game_logic_loop]

after_frame:
  psh acu
  mov8 &[!has_ended], acu
  jeq $00, &[!after_frame_2]
  mov8 $00, &[!has_ended]
  pop acu
  pop r8
  psh [!start]
  rti

after_frame_2:
  pop acu
  rti

data8 has_ended = { $00 }
data8 cars_offset = { $00 }